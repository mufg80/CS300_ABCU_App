# ABCUApp

This project required me to create a program that would read a text file from the disk. This file had course information on each line with each piece of information delimited by commas. Once this information was read from the disk, course objects were created and added to a data structure. Once a list was populated, the program needed to sort the courses in alphanumerical order and efficiently find a user-specified course. 

To complete this assignment, the available data structures and algorithms needed to be understood in order to select an efficient solution for this problem. I selected the C++ vector for this project and leveraged the binary search and quicksort algorithms. The data was read from the disk and placed into a vector, when the user requested to see the sorted list, the quick sort algorithm was called to sort the list efficiently, then another function would print each item to the console. If the user requested a specific course, the sorted list was passed to the binary search algorithm that would search the list for the specified course.

To complete this project I had to work through many obstacles, such as syntax issues and implementation mistakes. To overcome these roadblocks, I used several resources. For syntax and C++ errors I used online resources such as stack overflow and my college workbook. Some problems were not easily found online and I had to use the debugger to step through the code. 

This project has helped me expand my approach to designing software because it has helped me to understand the differences between the data structures themselves. For instance, if a process required many insertions and retrievals, I might have used a vector at one time without understanding the inefficiency involved. To insert an object into a vector requires moving all items down one position. A better choice might be a hashmap, so that insertions and retrievals could be implemented at a speed of O(1). 

The work on this project has helped me to improve the way I write programs in a number of ways, first, it has shown me the differences of just implementing any function that will work instead of the most efficient algorithm. One assignment required a quick sort and a selection sort algorithm to be implemented in the same program. We used timers to see the difference in efficiency between the two. Another improvement was in creating my own functions and annotating my code, following the single responsibility rule and splitting up functionality allowed me to reduce code duplication. For instance, I wrote a function to make a case insensitive comparison. By making this a function that took two strings, I could reuse this function in multiple places. Annotating code was another improvement, I created comments for each function as well as added comments inside functions to explain what was supposed to happen, days later when I started work on my project I used my own comments to help remember what was happening in the code. 
